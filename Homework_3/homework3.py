# -*- coding: utf-8 -*-
"""Homework3_Final2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12a2UkUXIMvRdmDG34jJyExlZy80oobjv
"""

import numpy as np
import matplotlib.pyplot as plt

## All functions below until getFb() are helper functions from the lectures
def crossMat(a):
    """
    Returns the cross product matrix of vector 'a'.

    Parameters:
    a : np.ndarray
        A 3-element array representing a vector.

    Returns:
    A : np.ndarray
        The cross product matrix corresponding to vector 'a'.
    """
    A = np.array([[0, -a[2], a[1]],
                  [a[2], 0, -a[0]],
                  [-a[1], a[0], 0]])

    return A

def gradEb(xkm1, ykm1, xk, yk, xkp1, ykp1, curvature0, l_k, EI):
    """
    Returns the derivative of bending energy E_k^b with respect to
    x_{k-1}, y_{k-1}, x_k, y_k, x_{k+1}, and y_{k+1}.

    Parameters:
    xkm1, ykm1 : float
        Coordinates of the previous node (x_{k-1}, y_{k-1}).
    xk, yk : float
        Coordinates of the current node (x_k, y_k).
    xkp1, ykp1 : float
        Coordinates of the next node (x_{k+1}, y_{k+1}).
    curvature0 : float
        Discrete natural curvature at node (xk, yk).
    l_k : float
        Voronoi length of node (xk, yk).
    EI : float
        Bending stiffness.

    Returns:
    dF : np.ndarray
        Derivative of bending energy.
    """

    # Nodes in 3D
    node0 = np.array([xkm1, ykm1, 0.0])
    node1 = np.array([xk, yk, 0])
    node2 = np.array([xkp1, ykp1, 0])

    # Unit vectors along z-axis
    m2e = np.array([0, 0, 1])
    m2f = np.array([0, 0, 1])

    kappaBar = curvature0

    # Initialize gradient of curvature
    gradKappa = np.zeros(6)

    # Edge vectors
    ee = node1 - node0
    ef = node2 - node1

    # Norms of edge vectors
    norm_e = np.linalg.norm(ee)
    norm_f = np.linalg.norm(ef)

    # Unit tangents
    te = ee / norm_e
    tf = ef / norm_f

    # Curvature binormal
    kb = 2.0 * np.cross(te, tf) / (1.0 + np.dot(te, tf))

    chi = 1.0 + np.dot(te, tf)
    tilde_t = (te + tf) / chi
    tilde_d2 = (m2e + m2f) / chi

    # Curvature
    kappa1 = kb[2]

    # Gradient of kappa1 with respect to edge vectors
    Dkappa1De = 1.0 / norm_e * (-kappa1 * tilde_t + np.cross(tf, tilde_d2))
    Dkappa1Df = 1.0 / norm_f * (-kappa1 * tilde_t - np.cross(te, tilde_d2))

    # Populate the gradient of kappa
    gradKappa[0:2] = -Dkappa1De[0:2]
    gradKappa[2:4] = Dkappa1De[0:2] - Dkappa1Df[0:2]
    gradKappa[4:6] = Dkappa1Df[0:2]

    # Gradient of bending energy
    dkappa = kappa1 - kappaBar
    dF = gradKappa * EI * dkappa / l_k

    return dF

def hessEb(xkm1, ykm1, xk, yk, xkp1, ykp1, curvature0, l_k, EI):
    """
    Returns the Hessian (second derivative) of bending energy E_k^b
    with respect to x_{k-1}, y_{k-1}, x_k, y_k, x_{k+1}, and y_{k+1}.

    Parameters:
    xkm1, ykm1 : float
        Coordinates of the previous node (x_{k-1}, y_{k-1}).
    xk, yk : float
        Coordinates of the current node (x_k, y_k).
    xkp1, ykp1 : float
        Coordinates of the next node (x_{k+1}, y_{k+1}).
    curvature0 : float
        Discrete natural curvature at node (xk, yk).
    l_k : float
        Voronoi length of node (xk, yk).
    EI : float
        Bending stiffness.

    Returns:
    dJ : np.ndarray
        Hessian of bending energy.
    """

    # Nodes in 3D
    node0 = np.array([xkm1, ykm1, 0])
    node1 = np.array([xk, yk, 0])
    node2 = np.array([xkp1, ykp1, 0])

    # Unit vectors along z-axis
    m2e = np.array([0, 0, 1])
    m2f = np.array([0, 0, 1])

    kappaBar = curvature0

    # Initialize gradient of curvature
    gradKappa = np.zeros(6)

    # Edge vectors
    ee = node1 - node0
    ef = node2 - node1

    # Norms of edge vectors
    norm_e = np.linalg.norm(ee)
    norm_f = np.linalg.norm(ef)

    # Unit tangents
    te = ee / norm_e
    tf = ef / norm_f

    # Curvature binormal
    kb = 2.0 * np.cross(te, tf) / (1.0 + np.dot(te, tf))

    chi = 1.0 + np.dot(te, tf)
    tilde_t = (te + tf) / chi
    tilde_d2 = (m2e + m2f) / chi

    # Curvature
    kappa1 = kb[2]

    # Gradient of kappa1 with respect to edge vectors
    Dkappa1De = 1.0 / norm_e * (-kappa1 * tilde_t + np.cross(tf, tilde_d2))
    Dkappa1Df = 1.0 / norm_f * (-kappa1 * tilde_t - np.cross(te, tilde_d2))

    # Populate the gradient of kappa
    gradKappa[0:2] = -Dkappa1De[0:2]
    gradKappa[2:4] = Dkappa1De[0:2] - Dkappa1Df[0:2]
    gradKappa[4:6] = Dkappa1Df[0:2]

    # Compute the Hessian (second derivative of kappa)
    DDkappa1 = np.zeros((6, 6))

    norm2_e = norm_e**2
    norm2_f = norm_f**2

    Id3 = np.eye(3)

    # Helper matrices for second derivatives
    tt_o_tt = np.outer(tilde_t, tilde_t)
    tmp = np.cross(tf, tilde_d2)
    tf_c_d2t_o_tt = np.outer(tmp, tilde_t)
    kb_o_d2e = np.outer(kb, m2e)

    D2kappa1De2 = (2 * kappa1 * tt_o_tt - tf_c_d2t_o_tt - tf_c_d2t_o_tt.T) / norm2_e - \
                  kappa1 / (chi * norm2_e) * (Id3 - np.outer(te, te)) + \
                  (kb_o_d2e + kb_o_d2e.T) / (4 * norm2_e)

    tmp = np.cross(te, tilde_d2)
    te_c_d2t_o_tt = np.outer(tmp, tilde_t)
    tt_o_te_c_d2t = te_c_d2t_o_tt.T
    kb_o_d2f = np.outer(kb, m2f)

    D2kappa1Df2 = (2 * kappa1 * tt_o_tt + te_c_d2t_o_tt + te_c_d2t_o_tt.T) / norm2_f - \
                  kappa1 / (chi * norm2_f) * (Id3 - np.outer(tf, tf)) + \
                  (kb_o_d2f + kb_o_d2f.T) / (4 * norm2_f)
    D2kappa1DeDf = -kappa1 / (chi * norm_e * norm_f) * (Id3 + np.outer(te, tf)) \
                  + 1.0 / (norm_e * norm_f) * (2 * kappa1 * tt_o_tt - tf_c_d2t_o_tt + \
                  tt_o_te_c_d2t - crossMat(tilde_d2))
    D2kappa1DfDe = D2kappa1DeDf.T

    # Populate the Hessian of kappa
    DDkappa1[0:2, 0:2] = D2kappa1De2[0:2, 0:2]
    DDkappa1[0:2, 2:4] = -D2kappa1De2[0:2, 0:2] + D2kappa1DeDf[0:2, 0:2]
    DDkappa1[0:2, 4:6] = -D2kappa1DeDf[0:2, 0:2]
    DDkappa1[2:4, 0:2] = -D2kappa1De2[0:2, 0:2] + D2kappa1DfDe[0:2, 0:2]
    DDkappa1[2:4, 2:4] = D2kappa1De2[0:2, 0:2] - D2kappa1DeDf[0:2, 0:2] - \
                         D2kappa1DfDe[0:2, 0:2] + D2kappa1Df2[0:2, 0:2]
    DDkappa1[2:4, 4:6] = D2kappa1DeDf[0:2, 0:2] - D2kappa1Df2[0:2, 0:2]
    DDkappa1[4:6, 0:2] = -D2kappa1DfDe[0:2, 0:2]
    DDkappa1[4:6, 2:4] = D2kappa1DfDe[0:2, 0:2] - D2kappa1Df2[0:2, 0:2]
    DDkappa1[4:6, 4:6] = D2kappa1Df2[0:2, 0:2]

    # Hessian of bending energy
    dkappa = kappa1 - kappaBar
    dJ = 1.0 / l_k * EI * np.outer(gradKappa, gradKappa)
    dJ += 1.0 / l_k * dkappa * EI * DDkappa1

    return dJ

def gradEs(xk, yk, xkp1, ykp1, l_k, EA):
    """
    Calculate the gradient of the stretching energy with respect to the coordinates.

    Args:
    - xk (float): x coordinate of the current point
    - yk (float): y coordinate of the current point
    - xkp1 (float): x coordinate of the next point
    - ykp1 (float): y coordinate of the next point
    - l_k (float): reference length
    - EA (float): elastic modulus

    Returns:
    - F (np.array): Gradient array
    """
    F = np.zeros(4)
    F[0] = -(1.0 - np.sqrt((xkp1 - xk)**2.0 + (ykp1 - yk)**2.0) / l_k) * ((xkp1 - xk)**2.0 + (ykp1 - yk)**2.0)**(-0.5) / l_k * (-2.0 * xkp1 + 2.0 * xk)
    F[1] = -(0.1e1 - np.sqrt((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) / l_k) * ((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.1e1 / 0.2e1) / l_k * (-0.2e1 * ykp1 + 0.2e1 * yk)
    F[2] = -(0.1e1 - np.sqrt((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) / l_k) * ((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.1e1 / 0.2e1) / l_k * (0.2e1 * xkp1 - 0.2e1 * xk)
    F[3] = -(0.1e1 - np.sqrt((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) / l_k) * ((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.1e1 / 0.2e1) / l_k * (0.2e1 * ykp1 - 0.2e1 * yk)

    F = 0.5 * EA * l_k * F  # Scale by EA and l_k

    return F

def hessEs(xk, yk, xkp1, ykp1, l_k, EA):
    """
    This function returns the 4x4 Hessian of the stretching energy E_k^s with
    respect to x_k, y_k, x_{k+1}, and y_{k+1}.
    """
    J = np.zeros((4, 4))  # Initialize the Hessian matrix
    J11 = (1 / ((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) / l_k ** 2 * (-2 * xkp1 + 2 * xk) ** 2) / 0.2e1 + (0.1e1 - np.sqrt(((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2)) / l_k) * (((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.3e1 / 0.2e1)) / l_k * ((-2 * xkp1 + 2 * xk) ** 2) / 0.2e1 - 0.2e1 * (0.1e1 - np.sqrt(((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2)) / l_k) * (((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.1e1 / 0.2e1)) / l_k
    J12 = (1 / ((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) / l_k ** 2 * (-2 * ykp1 + 2 * yk) * (-2 * xkp1 + 2 * xk)) / 0.2e1 + (0.1e1 - np.sqrt(((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2)) / l_k) * (((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.3e1 / 0.2e1)) / l_k * (-2 * xkp1 + 2 * xk) * (-2 * ykp1 + 2 * yk) / 0.2e1
    J13 = (1 / ((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) / l_k ** 2 * (2 * xkp1 - 2 * xk) * (-2 * xkp1 + 2 * xk)) / 0.2e1 + (0.1e1 - np.sqrt(((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2)) / l_k) * (((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.3e1 / 0.2e1)) / l_k * (-2 * xkp1 + 2 * xk) * (2 * xkp1 - 2 * xk) / 0.2e1 + 0.2e1 * (0.1e1 - np.sqrt(((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2)) / l_k) * (((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.1e1 / 0.2e1)) / l_k
    J14 = (1 / ((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) / l_k ** 2 * (2 * ykp1 - 2 * yk) * (-2 * xkp1 + 2 * xk)) / 0.2e1 + (0.1e1 - np.sqrt(((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2)) / l_k) * (((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.3e1 / 0.2e1)) / l_k * (-2 * xkp1 + 2 * xk) * (2 * ykp1 - 2 * yk) / 0.2e1
    J22 = (1 / ((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) / l_k ** 2 * (-2 * ykp1 + 2 * yk) ** 2) / 0.2e1 + (0.1e1 - np.sqrt(((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2)) / l_k) * (((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.3e1 / 0.2e1)) / l_k * ((-2 * ykp1 + 2 * yk) ** 2) / 0.2e1 - 0.2e1 * (0.1e1 - np.sqrt(((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2)) / l_k) * (((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.1e1 / 0.2e1)) / l_k
    J23 = (1 / ((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) / l_k ** 2 * (2 * xkp1 - 2 * xk) * (-2 * ykp1 + 2 * yk)) / 0.2e1 + (0.1e1 - np.sqrt(((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2)) / l_k) * (((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.3e1 / 0.2e1)) / l_k * (-2 * ykp1 + 2 * yk) * (2 * xkp1 - 2 * xk) / 0.2e1
    J24 = (1 / ((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) / l_k ** 2 * (2 * ykp1 - 2 * yk) * (-2 * ykp1 + 2 * yk)) / 0.2e1 + (0.1e1 - np.sqrt(((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2)) / l_k) * (((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.3e1 / 0.2e1)) / l_k * (-2 * ykp1 + 2 * yk) * (2 * ykp1 - 2 * yk) / 0.2e1 + 0.2e1 * (0.1e1 - np.sqrt(((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2)) / l_k) * (((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.1e1 / 0.2e1)) / l_k
    J33 = (1 / ((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) / l_k ** 2 * (2 * xkp1 - 2 * xk) ** 2) / 0.2e1 + (0.1e1 - np.sqrt(((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2)) / l_k) * (((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.3e1 / 0.2e1)) / l_k * ((2 * xkp1 - 2 * xk) ** 2) / 0.2e1 - 0.2e1 * (0.1e1 - np.sqrt(((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2)) / l_k) * (((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.1e1 / 0.2e1)) / l_k
    J34 = (1 / ((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) / l_k ** 2 * (2 * ykp1 - 2 * yk) * (2 * xkp1 - 2 * xk)) / 0.2e1 + (0.1e1 - np.sqrt(((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2)) / l_k) * (((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.3e1 / 0.2e1)) / l_k * (2 * xkp1 - 2 * xk) * (2 * ykp1 - 2 * yk) / 0.2e1
    J44 = (1 / ((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) / l_k ** 2 * (2 * ykp1 - 2 * yk) ** 2) / 0.2e1 + (0.1e1 - np.sqrt(((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2)) / l_k) * (((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.3e1 / 0.2e1)) / l_k * ((2 * ykp1 - 2 * yk) ** 2) / 0.2e1 - 0.2e1 * (0.1e1 - np.sqrt(((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2)) / l_k) * (((xkp1 - xk) ** 2 + (ykp1 - yk) ** 2) ** (-0.1e1 / 0.2e1)) / l_k

    J = np.array([[J11, J12, J13, J14],
                   [J12, J22, J23, J24],
                   [J13, J23, J33, J34],
                   [J14, J24, J34, J44]])

    J *= 0.5 * EA * l_k

    return J

def getFs(q, EA, deltaL):
  # q - DOF vector of size N
  # EA - stretching stiffness
  # deltaL - undeformed reference length (assume to be a scalar for this simple example)
  # Output:
  # Fs - a vector (negative gradient of elastic stretching force)
  # Js - a matrix (negative hessian of elastic stretching force)

  ndof = q.size # Number of DOFs
  N = ndof // 2 # Number of nodes

  Fs = np.zeros(ndof) # stretching force
  Js = np.zeros((ndof, ndof))

  for k in range(0, N-1):
      # May need to modify if network of beams
      # k-th stretching spring (USE A LOOP for the general case
      xkm1 = q[2*k] # x coordinate of the first node
      ykm1 = q[2*k+1] # y coordinate of the first node
      xk = q[2*k+2] # x coordinate of the second node
      yk = q[2*k+3] # y coordinate of the second node
      ind = np.arange(2*k, 2*k+4) # 0, 1, 2, 3 for k = 0
      gradEnergy = gradEs(xkm1, ykm1, xk, yk, deltaL, EA)
      hessEnergy = hessEs(xkm1, ykm1, xk, yk, deltaL, EA)

      Fs[ind] -= gradEnergy # force = - gradient of energy. Fs is the stretching force
      Js[np.ix_(ind, ind)] -= hessEnergy # index vector: 0:4

  return Fs, Js

def getFb(q, EI, deltaL):
  # q - DOF vector of size N
  # EI - bending stiffness
  # deltaL - undeformed Voronoi length (assume to be a scalar for this simple example)
  # Output:
  # Fb - a vector (negative gradient of elastic stretching force)
  # Jb - a matrix (negative hessian of elastic stretching force)

  ndof = q.size # Number of DOFs
  N = ndof // 2 # Number of nodes

  Fb = np.zeros(ndof) # bending force
  Jb = np.zeros((ndof, ndof))

  # First bending spring (USE A LOOP for the general case)
  for k in range(1, N-1):
    xkm1 = q[2*k-2] # x coordinate of the first node
    ykm1 = q[2*k-1] # y coordinate of the first node
    xk = q[2*k] # x coordinate of the second node
    yk = q[2*k+1] # y coordinate of the second node
    xkp1 = q[2*k+2] # x coordinate of the third node
    ykp1 = q[2*k+3] # y coordinate of the third node
    ind = np.arange(2*k-2, 2*k+4)
    gradEnergy = gradEb(xkm1, ykm1, xk, yk, xkp1, ykp1, 0, deltaL, EI)
    hessEnergy = hessEb(xkm1, ykm1, xk, yk, xkp1, ykp1, 0, deltaL, EI)

    Fb[ind] -= gradEnergy # force = - gradient of energy. Fb is the stretching force
    Jb[np.ix_(ind, ind)] -= hessEnergy # index vector: 0:6

  return Fb, Jb

def compute_control_inputs(t, L):
    """ Computes intial path for the control node"""
    # Nominal control inputs based on prescribed end-effector trajectory
    # These are the original desired trajectory for the end-effector
    x_c = L * np.cos(np.pi * t / 2000)
    y_c = -L * np.sin(np.pi * t / 2000)
    theta_c = -t * np.pi / 2000

    return x_c, y_c, theta_c

def compute_target_position(t, L):
    """Compute desired position of middle node at time t."""
    x_star = (L / 2) * np.cos(np.pi * t / 2000)
    y_star = -(L / 2) * np.sin(np.pi * t / 2000)
    return x_star, y_star

def objfun_with_control(qGuess, q0, u, freeIndex,
                        dt, tol, massVector, mMat,
                        EA, deltaL, EI, Fg,
                        x_c, y_c, theta_c, N):
    """Objective function with Dirichlet boundary conditions at right end."""
    q = qGuess.copy()

    # Apply Dirichlet boundary conditions
    # Last node (N-1 in 0-indexed)
    q[2*(N-1)] = x_c
    q[2*(N-1) + 1] = y_c

    # Second to last node (N-2)
    q[2*(N-2)] = x_c - deltaL * np.cos(theta_c)
    q[2*(N-2) + 1] = y_c - deltaL * np.sin(theta_c)

    iter_count = 0
    error = 10 * tol
    max_iter = 100

    while error > tol and iter_count < max_iter:
        Fb, Jb = getFb(q, EI, deltaL)
        Fs, Js = getFs(q, EA, deltaL)

        Forces = Fb + Fs + Fg
        JForces = Jb + Js
        f = np.dot(mMat / dt, (q - q0) / dt - u) - Forces
        J = mMat / dt**2 - JForces

        f_free = f[freeIndex]
        J_free = J[np.ix_(freeIndex, freeIndex)]

        dq_free = np.linalg.solve(J_free, f_free)
        q[freeIndex] = q[freeIndex] - dq_free

        # Reapply boundary conditions
        q[2*(N-1)] = x_c
        q[2*(N-1) + 1] = y_c
        q[2*(N-2)] = x_c - deltaL * np.cos(theta_c)
        q[2*(N-2) + 1] = y_c - deltaL * np.sin(theta_c)

        error = np.sum(np.abs(f_free))
        iter_count += 1

    u = (q - q0) / dt
    return q, u

# MAIN
# Geometry & Material
L = 1.0  # Beam length (m)
R = 0.013  # Outer radius (m)
r = 0.011  # Inner radius (m)
E = 70e9  # Young's modulus (Pa)
rho = 2700  # Density (kg/m^3)

# Discrete
N = 19  # Number of nodes
ne = N - 1
deltaL = L / (N - 1)
ndof = 2 * N  # Only x,y coordinates (planar)

# Material properties
A = np.pi * (R**2 - r**2)
I = np.pi * (R**4 - r**4) / 4
EA = E * A
EI = E * I

# Mass per node
m = rho * A * L / (N - 1)

# Initialize nodes
nodes = np.zeros((N, 2))
for c in range(N):
    nodes[c, 0] = c * deltaL
    nodes[c, 1] = 0

# Mass vector
massVector = np.zeros(ndof)
for c in range(N):
    ind = [2*c, 2*c+1]
    if c == 0 or c == N - 1:
        massVector[ind] = m / 2
    else:
        massVector[ind] = m

mMat = np.diag(massVector)

# Gravity
g = 9.81
Fg = np.zeros(ndof)
for c in range(N):
    ind = [2*c, 2*c+1]
    Fg[ind] = massVector[ind] * np.array([0, -g])

# Initial DOF
q0 = np.zeros(ndof)
for c in range(N):
    q0[2*c] = nodes[c, 0]
    q0[2*c+1] = nodes[c, 1]
u = np.zeros(ndof)

# Boundary conditions
# Fixed: left end (node 0) - 2 position DOFs
# Controlled: right end (nodes N-1 and N-2) - handled in objfun
fixedIndex = np.array([0, 1])  # x, y of first node
controlledIndex = np.array([2*(N-2), 2*(N-2)+1, 2*(N-1), 2*(N-1)+1])
freeIndex = np.setdiff1d(np.arange(ndof), np.concatenate([fixedIndex, controlledIndex]))

# Time parameters
totalTime = 1000  # seconds
dt = 0.1
Nsteps = int(totalTime / dt)
tol = EI / L**2 * 1e-3

# Middle node
middle_idx = N // 2 # 9 (10 from 0)

# P gain
Kp_x = 1.5
Kp_y = 1.5
Kp_theta = 0.5

# Integral gain
Ki_x = 0.005
Ki_y = 0.005
Ki_theta = 0.002

# Derivative gain
Kd_x = 0.1
Kd_y = 0.1
Kd_theta = 0.05

# Parameters for inner iteration
control_tolerance = 1e-6 # meters
max_inner_iterations = 50

# Storage for results
time_array = np.linspace(0, totalTime, Nsteps)
x_c_array = np.zeros(Nsteps)
y_c_array = np.zeros(Nsteps)
theta_c_array = np.zeros(Nsteps)
x_mid_array = np.zeros(Nsteps)
y_mid_array = np.zeros(Nsteps)
x_star_array = np.zeros(Nsteps)
y_star_array = np.zeros(Nsteps)

num_snapshots_to_save = 5
# snapshot_times_to_save is still generated for plotting purposes
snapshot_times_to_save = np.linspace(0, totalTime, num_snapshots_to_save)
snapshots = []

# Determine the step interval for saving snapshots
snapshot_interval_steps = Nsteps // num_snapshots_to_save

# Time loop
ctime = 0

for step in range(Nsteps):
    x_star, y_star = compute_target_position(ctime, L)
    x_star_array[step] = x_star
    y_star_array[step] = y_star

    # Get nominal control inputs
    x_c, y_c, theta_c = compute_control_inputs(ctime, L)

    # Initialize for inner loop
    q_current_step = q0.copy()
    u_current_step = u.copy()
    error = float('inf') # Initialize error to a large value
    inner_iter = 0

    # Intergal history for time step
    integral_error_x = 0.0
    integral_error_y = 0.0

    # derivative
    previous_error_x = 0.0
    previous_error_y = 0.0

    # For theta_c adjustment based on y_error
    previous_error_y_for_theta = 0.0

    # Inner loop PID controller
    while error > control_tolerance and inner_iter < max_inner_iterations:
        # Simulate beam response with current control inputs
        q_simulated, u_simulated = objfun_with_control(q_current_step, q0, u_current_step, freeIndex,
                                                       dt, tol, massVector, mMat,
                                                       EA, deltaL, EI, Fg,
                                                       x_c, y_c, theta_c, N)

        # Extract actual middle node position from simulated configuration
        x_mid_actual = q_simulated[2 * middle_idx]
        y_mid_actual = q_simulated[2 * middle_idx + 1]

        # Calculate Euclidean distance error
        error = np.sqrt((x_mid_actual - x_star)**2 + (y_mid_actual - y_star)**2)

        if error <= control_tolerance or inner_iter == max_inner_iterations - 1:
            # If converged or last iteration, use these values
            break

        # Calculate tracking error components
        error_x = x_star - x_mid_actual
        error_y = y_star - y_mid_actual

        # Update integral terms
        integral_error_x += error_x
        integral_error_y += error_y

        # Calculate derivative terms
        derivative_error_x = error_x - previous_error_x
        derivative_error_y = error_y - previous_error_y
        derivative_error_y_for_theta = error_y - previous_error_y_for_theta

        # Adjust control inputs using PID feedback
        x_c += (Kp_x * error_x + Ki_x * integral_error_x + Kd_x * derivative_error_x)
        y_c += (Kp_y * error_y + Ki_y * integral_error_y + Kd_y * derivative_error_y)
        theta_c += (Kp_theta * error_y + Ki_theta * integral_error_y + Kd_theta * derivative_error_y_for_theta)

        # Update previous errors for the next inner iteration
        previous_error_x = error_x
        previous_error_y = error_y
        previous_error_y_for_theta = error_y

        inner_iter += 1
        q_current_step = q_simulated.copy()
        u_current_step = u_simulated.copy() # Need to pass updated u for consistency

    # Store the final adjusted control inputs and actual middle node position for this time step
    x_c_array[step] = x_c
    y_c_array[step] = y_c
    theta_c_array[step] = theta_c

    x_mid_array[step] = x_mid_actual
    y_mid_array[step] = y_mid_actual

    # Update q0 and u for the next outer time step with the converged values
    q0 = q_simulated.copy()
    u = u_simulated.copy()

    # Save snapshot
    if step % snapshot_interval_steps == 0:
        snapshots.append((ctime, q0.copy()))

    ctime += dt

# PLOTS
# Plot 1: Control inputs
fig, axes = plt.subplots(3, 1, figsize=(10, 8))
axes[0].plot(time_array, x_c_array, 'b-', linewidth=1.5)
axes[0].set_ylabel('$x_c$ (m)')
axes[0].grid(True)
axes[0].set_title('Control Inputs Over Time')

axes[1].plot(time_array, y_c_array, 'r-', linewidth=1.5)
axes[1].set_ylabel('$y_c$ (m)')
axes[1].grid(True)

axes[2].plot(time_array, theta_c_array * 180/np.pi, 'g-', linewidth=1.5)
axes[2].set_xlabel('Time (s)')
axes[2].set_ylabel('$\\theta_c$ (deg)')
axes[2].grid(True)
plt.tight_layout()
plt.savefig('control_inputs.png', dpi=300, bbox_inches='tight')
plt.show()

# Plot 2: Tracking performance
fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(time_array, x_star_array, 'b--', linewidth=2, label='Desired $x^*$')
ax.plot(time_array, x_mid_array, 'b-', linewidth=1.5, label='Actual $x_{mid}$')
ax.plot(time_array, y_star_array, 'r--', linewidth=2, label='Desired $y^*$')
ax.plot(time_array, y_mid_array, 'r-', linewidth=1.5, label='Actual $y_{mid}$')
ax.set_xlabel('Time (s)')
ax.set_ylabel('Position (m)')
ax.set_title('Middle Node Tracking Performance')
ax.legend()
ax.grid(True)
plt.savefig('tracking_performance.png', dpi=300, bbox_inches='tight')
plt.show()

# Plot 3: Trajectory
fig, ax = plt.subplots(figsize=(8, 8))
ax.plot(x_star_array, y_star_array, 'k--', linewidth=2, label='Desired trajectory')
ax.plot(x_mid_array, y_mid_array, 'b-', linewidth=1.5, label='Actual trajectory')
ax.set_xlabel('x (m)')
ax.set_ylabel('y (m)')
ax.set_title('Middle Node Trajectory')
ax.legend()
ax.grid(True)
ax.axis('equal')
plt.savefig('trajectory_xy.png', dpi=300, bbox_inches='tight')
plt.show()

# Plot 4: Beam snapshots
snapshots_to_plot = snapshots
num_plots = len(snapshots_to_plot)
rows = int(np.ceil(np.sqrt(num_plots)))
cols = int(np.ceil(num_plots / rows))

fig, axes = plt.subplots(rows, cols, figsize=(15, 15))
axes = axes.flatten()

for idx, (t, q_snap) in enumerate(snapshots_to_plot):
    if idx < len(axes):
        ax = axes[idx]
        x_nodes = q_snap[0::2]
        y_nodes = q_snap[1::2]

        ax.plot(x_nodes, y_nodes, 'ko-', linewidth=1, markersize=2)
        ax.plot([x_nodes[0]], [y_nodes[0]], 'rs', markersize=5, label='Fixed end')
        ax.plot([x_nodes[middle_idx]], [y_nodes[middle_idx]], 'bo',
                markersize=5, label='Middle node')
        ax.plot([x_nodes[-1]], [y_nodes[-1]], 'g^', markersize=5, label='End Point')

        x_s, y_s = compute_target_position(t, L)
        ax.plot([x_s], [y_s], 'bx', markersize=6, markeredgewidth=2,
                label='Target')

        ax.set_xlabel('x (m)', fontsize=6)
        ax.set_ylabel('y (m)', fontsize=6)
        ax.set_title(f't = {t:.1f} s', fontsize=8)
        ax.grid(True)
        ax.axis('equal')
        ax.tick_params(labelsize=6)
        if idx == 0:
            ax.legend(fontsize=6)
        else:
            if ax.get_legend() is not None:
                ax.get_legend().remove()

# Remove any unused subplots
if num_plots < len(axes):
    for idx in range(num_plots, len(axes)):
        fig.delaxes(axes[idx])

fig.tight_layout()
plt.savefig('beam_snapshots.png', dpi=300, bbox_inches='tight')
plt.show()

# Plot 5: Tracking error
tracking_error = np.sqrt((x_mid_array - x_star_array)**2 +
                         (y_mid_array - y_star_array)**2)
fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(time_array, tracking_error * 1000000, 'r-', linewidth=1.5)
ax.set_xlabel('Time (s)')
ax.set_ylabel(f'Tracking Error ({chr(956)}m)')
ax.set_title('Middle Node Tracking Error')
ax.grid(True)
plt.savefig('tracking_error.png', dpi=300, bbox_inches='tight')
plt.show()